// Generated by CoffeeScript 1.6.3
(function() {
  var analyzeScHelpPage, closeTabs, dfdCommandQueue, execCommand, flexkbd, forecast, getActiveTab, getAllTabs, getAllTabs2, getWindowTabs, jsUitlObj, openBookmark, optionsTabId, preOpenBookmark, preSendKeyEvent, scHelp, scHelpPageUrl, scHelpSect, scrapeHelp, sendKeyEventToDom, sendMessage, setConfigPlugin, xhr,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  flexkbd = document.getElementById("flexkbd");

  (dfdCommandQueue = $.Deferred()).resolve();

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    var i, kbdtype, keyIdentifier, keys, local, modifierChars, modifiers, modifiersCode, scCode, scanCode, srCode, test, transCode, _i, _j, _ref, _results;
    switch (request.action) {
      case "callShortcut":
        if ((transCode = request.value1) === "") {
          srCode = "";
        } else {
          test = transCode.match(/\[(\w*)\](.+)/, "g");
          if (test) {
            local = fk.getConfig();
            modifiersCode = 0;
            scCode = "";
            if (modifiers = RegExp.$1) {
              modifierChars = modifiers.toLowerCase().split("");
              if ((__indexOf.call(modifierChars, "c") >= 0)) {
                modifiersCode = 1;
              }
              if ((__indexOf.call(modifierChars, "a") >= 0)) {
                modifiersCode += 2;
              }
              if ((__indexOf.call(modifierChars, "s") >= 0)) {
                modifiersCode += 4;
              }
              if ((__indexOf.call(modifierChars, "w") >= 0)) {
                modifiersCode += 8;
              }
            }
            if (keyIdentifier = RegExp.$2) {
              kbdtype = local.config.kbdtype;
              keys = fk.getKeyCodes()[kbdtype].keys;
              scanCode = -1;
              for (i = _i = 0, _ref = keys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (keys[i] && (keyIdentifier === keys[i][0] || keyIdentifier === keys[i][1])) {
                  scanCode = i;
                  break;
                }
              }
              if (scanCode === -1) {
                sendResponse("Key identifier code '" + keyIdentifier + "' is unregistered code.");
                return;
              } else {
                if (modifiersCode === 0 && !(__indexOf.call((function() {
                  _results = [];
                  for (var _j = 0x3B; 0x3B <= 0x44 ? _j <= 0x44 : _j >= 0x44; 0x3B <= 0x44 ? _j++ : _j--){ _results.push(_j); }
                  return _results;
                }).apply(this), scanCode) >= 0) && !(scanCode === 0x57 || scanCode === 0x58)) {
                  sendResponse("Modifier code is not included in '" + transCode + "'.");
                  return;
                } else {
                  scCode = "0" + modifiersCode.toString(16) + scanCode;
                }
              }
            } else {
              sendResponse("Key identifier code '" + transCode + "' is not found.");
              return;
            }
          } else {
            sendResponse("Shortcut code '" + transCode + "' is invalid.");
            return;
          }
        }
        dfdCommandQueue = dfdCommandQueue.then(function() {
          var dfd, e, found, item, preSleep, _k, _ref1;
          dfd = $.Deferred();
          try {
            if ((preSleep = request.value3) > 0) {
              flexkbd.Sleep(preSleep);
            }
            found = false;
            for (i = _k = 0, _ref1 = local.keyConfigSet.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
              if ((item = local.keyConfigSet[i]).proxy === scCode) {
                found = true;
                switch (item.mode) {
                  case "command":
                    execCommand(scCode).done(function() {
                      var postSleep;
                      if ((postSleep = request.value2) > 0) {
                        flexkbd.Sleep(postSleep);
                      }
                      dfd.resolve();
                      return sendResponse("done");
                    });
                    break;
                  case "bookmark":
                    preOpenBookmark(scCode).done(function() {
                      var postSleep;
                      if ((postSleep = request.value2) > 0) {
                        flexkbd.Sleep(postSleep);
                      }
                      dfd.resolve();
                      return sendResponse("done");
                    });
                    break;
                  case "sendToDom":
                    preSendKeyEvent(scCode).done(function() {
                      var postSleep;
                      if ((postSleep = request.value2) > 0) {
                        flexkbd.Sleep(postSleep);
                      }
                      dfd.resolve();
                      return sendResponse("done");
                    });
                    break;
                  default:
                    setTimeout((function() {
                      var postSleep;
                      flexkbd.CallShortcut(scCode);
                      if ((postSleep = request.value2) > 0) {
                        flexkbd.Sleep(postSleep);
                      }
                      dfd.resolve();
                      return sendResponse("done");
                    }), 0);
                }
                break;
              }
            }
            if (!found) {
              setTimeout((function() {
                var postSleep;
                flexkbd.CallShortcut(scCode);
                if ((postSleep = request.value2) > 0) {
                  flexkbd.Sleep(postSleep);
                  dfd.resolve();
                  return sendResponse("done");
                }
              }), 0);
            }
          } catch (_error) {
            e = _error;
            sendResponse(e.message);
            dfd.resolve();
          }
          return dfd.promise();
        });
        break;
      case "sleep":
        dfdCommandQueue = dfdCommandQueue.then(function() {
          var dfd;
          dfd = $.Deferred();
          setTimeout((function() {
            flexkbd.Sleep(request.msec);
            return dfd.resolve();
          }), 0);
          return dfd.promise();
        });
        break;
      case "setClipboard":
        dfdCommandQueue = dfdCommandQueue.then(function() {
          var dfd;
          dfd = $.Deferred();
          setTimeout((function() {
            flexkbd.SetClipboard(request.value1);
            dfd.resolve();
            return sendResponse("done");
          }), 0);
          return dfd.promise();
        });
    }
    return true;
  });

  jsUitlObj = "var Messenger = function() {\n  this.doneCallback = null;\n  this.done = function(callback) {\n    this.doneCallback = callback;\n    return this;\n  }\n  this.failCallback = null;\n  this.fail = function(callback) {\n    this.failCallback = callback;\n    return this;\n  }\n  this.sendMessage = function(action, value1, value2, value3) {\n    var that = this;\n    chrome.runtime.sendMessage({\n      action: action,\n      value1: value1,\n      value2: value2,\n      value3: value3\n    }, function(resp) {\n      if (resp === \"done\") {\n        if (that.doneCallback) {\n          that.doneCallback(resp);\n        }\n      } else {\n        if (that.failCallback) {\n          that.failCallback(resp);\n        }\n      }\n    });\n    return this;\n  }\n}\ntsc = {\n  send: function(transCode, postSleep, preSleep) {\n    var postMsec = 100, preMsec = 0;\n    if (postSleep != null) {\n      if (Number.isNaN(postMsec = parseInt(postSleep, 10))) {\n        alert(postSleep + \" is not a number.\");\n        return;\n      }\n    }\n    if (preSleep != null) {\n      if (Number.isNaN(preMsec = parseInt(preSleep, 10))) {\n        alert(preSleep + \" is not a number.\");\n        return;\n      }\n    }\n    return (new Messenger()).sendMessage(\"callShortcut\", transCode, postMsec, preMsec);\n  },\n  sleep: function(sleepMSec) {\n    var msec = 0;\n    if (sleepMSec != null) {\n      if (Number.isNaN(msec = parseInt(sleepMSec, 10))) {\n        alert(sleepMSec + \" is not a number.\");\n        return;\n      }\n    }\n    if (msec !== 0) {\n      chrome.runtime.sendMessage({\n        action: \"sleep\",\n        msec: sleepMSec\n      });\n    }\n  },\n  clipbd: function(text) {\n    return (new Messenger()).sendMessage(\"setClipboard\", text);\n  }\n};";

  sendMessage = function(message) {
    return chrome.tabs.query({
      active: true
    }, function(tabs) {
      return chrome.tabs.sendMessage(tabs[0].id, message);
    });
  };

  getActiveTab = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      return chrome.tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        return dfd.resolve(tabs[0], win.id);
      });
    });
    return dfd.promise();
  };

  getWindowTabs = function(options) {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      options.windowId = win.id;
      return chrome.tabs.query(options, function(tabs) {
        return dfd.resolve(tabs);
      });
    });
    return dfd.promise();
  };

  getAllTabs = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.tabs.query({}, function(tabs) {
      return dfd.resolve(tabs);
    });
    return dfd.promise();
  };

  getAllTabs2 = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getAll({
      populate: true
    }, function(windows) {
      var tabs;
      tabs = [];
      windows.forEach(function(win) {
        return tabs = tabs.concat(win.tabs);
      });
      return dfd.resolve(tabs);
    });
    return dfd.promise();
  };

  optionsTabId = null;

  chrome.tabs.onActivated.addListener(function(activeInfo) {
    return chrome.tabs.get(activeInfo.tabId, function(tab) {
      if (tab.url.indexOf(chrome.extension.getURL("")) === 0) {
        flexkbd.StartConfigMode();
        return optionsTabId = activeInfo.tabId;
      } else {
        if (optionsTabId) {
          chrome.tabs.sendMessage(optionsTabId, {
            action: "saveConfig"
          });
          return optionsTabId = null;
        }
      }
    });
  });

  chrome.windows.onFocusChanged.addListener(function(windowId) {
    if (optionsTabId) {
      chrome.tabs.sendMessage(optionsTabId, {
        action: "saveConfig"
      });
      return optionsTabId = null;
    } else {
      return getActiveTab().done(function(tab) {
        if (tab.url.indexOf(chrome.extension.getURL("")) === 0) {
          flexkbd.StartConfigMode();
          return optionsTabId = tab.id;
        }
      });
    }
  });

  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    if (tab.url.indexOf(chrome.extension.getURL("")) === 0 && (changeInfo.status = "complete")) {
      return flexkbd.StartConfigMode();
    }
  });

  sendKeyEventToDom = function(keyEvent, tabId) {
    var keyIdentifier, keyIdentifiers, keys, local, modifiers, scanCode, shift;
    local = fk.getConfig();
    keys = fk.getKeyCodes()[local.config.kbdtype].keys;
    modifiers = parseInt(keyEvent.substring(0, 2), 16);
    scanCode = keyEvent.substring(2);
    keyIdentifiers = keys[scanCode];
    if (shift = (modifiers & 4) !== 0) {
      keyIdentifier = keyIdentifiers[1] || keyIdentifiers[0];
    } else {
      keyIdentifier = keyIdentifiers[0];
    }
    return chrome.tabs.sendMessage(tabId, {
      action: "keyEvent",
      keyIdentifier: keyIdentifier,
      ctrl: (modifiers & 1) !== 0,
      alt: (modifiers & 2) !== 0,
      shift: shift,
      meta: (modifiers & 8) !== 0
    });
  };

  preSendKeyEvent = function(keyEvent) {
    var dfd;
    dfd = $.Deferred();
    chrome.tabs.query({
      active: true
    }, function(tabs) {
      var tabId;
      tabId = tabs[0].id;
      return chrome.tabs.sendMessage(tabId, {
        action: "askAlive"
      }, function(resp) {
        if (resp === "hello") {
          sendKeyEventToDom(keyEvent, tabId);
          return dfd.resolve();
        } else {
          return chrome.tabs.executeScript(tabId, {
            file: "kbdagent.js",
            allFrames: true
          }, function(resp) {
            sendKeyEventToDom(keyEvent, tabId);
            return dfd.resolve();
          });
        }
      });
    });
    return dfd.promise();
  };

  openBookmark = function(dfd, openmode, url) {
    switch (openmode) {
      case "newtab":
        return chrome.tabs.create({
          url: url
        }, function() {
          return dfd.resolve();
        });
      case "current":
        return chrome.tabs.query({
          active: true
        }, function(tabs) {
          return chrome.tabs.update(tabs[0].id, {
            url: url
          }, function() {
            return dfd.resolve();
          });
        });
      case "newwin":
        return chrome.windows.create({
          url: url
        }, function() {
          return dfd.resolve();
        });
      case "incognito":
        return chrome.windows.create({
          url: url,
          incognito: true
        }, function() {
          return dfd.resolve();
        });
    }
  };

  preOpenBookmark = function(keyEvent) {
    var dfd, local;
    dfd = $.Deferred();
    local = fk.getConfig();
    local.keyConfigSet.forEach(function(item) {
      var findStr, findtab, openmode, url, _ref;
      if (item.proxy === keyEvent) {
        _ref = item.bookmark, openmode = _ref.openmode, url = _ref.url, findtab = _ref.findtab, findStr = _ref.findStr;
        if (findtab) {
          return getActiveTab().done(function(activeTab) {
            return getAllTabs().done(function(tabs) {
              var currentPos, found, i, orderedTabs, _i, _j, _ref1, _ref2;
              currentPos = 0;
              for (i = _i = 0, _ref1 = tabs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                if (tabs[i].id === activeTab.id) {
                  currentPos = i;
                  break;
                }
              }
              orderedTabs = [];
              if ((0 < currentPos && currentPos < (tabs.length - 1))) {
                orderedTabs = tabs.slice(currentPos + 1).concat(tabs.slice(0, currentPos + 1));
              } else {
                orderedTabs = tabs;
              }
              found = false;
              for (i = _j = 0, _ref2 = orderedTabs.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                if ((orderedTabs[i].title + orderedTabs[i].url).indexOf(findStr) !== -1) {
                  chrome.tabs.update(orderedTabs[i].id, {
                    active: true
                  }, function() {
                    return dfd.resolve();
                  });
                  found = true;
                  break;
                }
              }
              if (!found) {
                return openBookmark(dfd, openmode, url);
              }
            });
          });
        } else {
          return openBookmark(dfd, openmode, url);
        }
      }
    });
    return dfd.promise();
  };

  closeTabs = function(dfd, fnWhere) {
    return getWindowTabs({
      active: false,
      currentWindow: true,
      windowType: "normal"
    }, fnWhere).done(function(tabs) {
      var tabIds;
      tabIds = [];
      tabs.forEach(function(tab) {
        if (fnWhere(tab)) {
          return tabIds.push(tab.id);
        }
      });
      if (tabIds.length > 0) {
        return chrome.tabs.remove(tabIds, function() {
          return dfd.resolve();
        });
      }
    });
  };

  execCommand = function(keyEvent) {
    var dfd, local, pos;
    dfd = $.Deferred();
    local = fk.getConfig();
    pos = 0;
    local.keyConfigSet.forEach(function(item) {
      var code, command;
      if (item.proxy === keyEvent) {
        switch (command = item.command.name) {
          case "closeOtherTabs":
            return closeTabs(dfd, function() {
              return true;
            });
          case "closeTabsRight":
          case "closeTabsLeft":
            return getActiveTab().done(function(tab) {
              pos = tab.index;
              if (command === "closeTabsRight") {
                return closeTabs(dfd, function(tab) {
                  return tab.index > pos;
                });
              } else {
                return closeTabs(dfd, function(tab) {
                  return tab.index < pos;
                });
              }
            });
          case "moveTabRight":
          case "moveTabLeft":
            return getActiveTab().done(function(tab, windowId) {
              var newpos;
              newpos = tab.index;
              if (command === "moveTabRight") {
                newpos = newpos + 1;
              } else {
                newpos = newpos - 1;
              }
              if (newpos > -1) {
                return chrome.tabs.move(tab.id, {
                  windowId: windowId,
                  index: newpos
                }, function() {
                  return dfd.resolve();
                });
              }
            });
          case "moveTabFirst":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 0
              }, function() {
                return dfd.resolve();
              });
            });
          case "moveTabLast":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 1000
              }, function() {
                return dfd.resolve();
              });
            });
          case "detachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.create({
                tabId: tab.id,
                focused: true,
                type: "normal"
              }, function() {
                return dfd.resolve();
              });
            });
          case "attachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.getAll({
                populate: true
              }, function(windows) {
                var currentWindowId, i, j, newWindowId, newwin, _i, _j, _ref, _ref1;
                for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  for (j = _j = 0, _ref1 = windows[i].tabs.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                    if (tab.id === windows[i].tabs[j].id) {
                      currentWindowId = i;
                      break;
                    }
                  }
                }
                if (newwin = windows[++currentWindowId]) {
                  newWindowId = newwin.id;
                } else {
                  newWindowId = windows[0].id;
                }
                return chrome.tabs.move(tab.id, {
                  windowId: newWindowId,
                  index: 1000
                }, function() {
                  return chrome.tabs.update(tab.id, {
                    active: true
                  }, function() {
                    return dfd.resolve();
                  });
                });
              });
            });
          case "duplicateTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function() {
                return dfd.resolve();
              });
            });
          case "duplicateTabWin":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function(tab) {
                return chrome.windows.create({
                  tabId: tab.id,
                  focused: true,
                  type: "normal"
                }, function() {
                  return dfd.resolve();
                });
              });
            });
          case "pinTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.update(tab.id, {
                pinned: !tab.pinned
              }, function() {
                return dfd.resolve();
              });
            });
          case "switchNextWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === windows.length - 1) {
                    chrome.windows.update(windows[0].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  } else {
                    chrome.windows.update(windows[i + 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "switchPrevWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === 0) {
                    chrome.windows.update(windows[windows.length - 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  } else {
                    chrome.windows.update(windows[i - 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "pasteText":
            return setTimeout((function() {
              flexkbd.PasteText(item.command.content);
              return dfd.resolve();
            }), 0);
          case "insertCSS":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.insertCSS(tab.id, {
                code: item.command.content,
                allFrames: item.command.allFrames
              }, function() {
                return dfd.resolve();
              });
            });
          case "execJS":
            code = item.command.content;
            if (item.command.useUtilObj) {
              code = jsUitlObj + code;
            }
            return getActiveTab().done(function(tab) {
              return chrome.tabs.executeScript(tab.id, {
                code: code,
                allFrames: item.command.allFrames
              }, function() {
                return dfd.resolve();
              });
            });
        }
      }
    });
    return dfd.promise();
  };

  setConfigPlugin = function(keyConfigSet) {
    var sendData;
    sendData = [];
    if (keyConfigSet) {
      keyConfigSet.forEach(function(item) {
        if (item.proxy) {
          return sendData.push([item.proxy, item.origin, item.mode].join(";"));
        }
      });
      return flexkbd.SetKeyConfig(sendData.join("|"));
    }
  };

  window.fk = {
    saveConfig: function(saveData) {
      localStorage.flexkbd = JSON.stringify(saveData);
      return setConfigPlugin(saveData.keyConfigSet);
    },
    getKeyCodes: function() {
      return {
        JP: {
          keys: keysJP,
          name: "JP 109 Keyboard"
        },
        US: {
          keys: keysUS,
          name: "US 104 Keyboard"
        }
      };
    },
    getScHelp: function() {
      return scHelp;
    },
    getScHelpSect: function() {
      return scHelpSect;
    },
    getConfig: function() {
      return JSON.parse(localStorage.flexkbd || null) || {
        config: {
          kbdtype: "JP"
        }
      };
    },
    startEdit: function() {
      return flexkbd.EndConfigMode();
    },
    endEdit: function() {
      return flexkbd.StartConfigMode();
    }
  };

  window.pluginEvent = function(action, value) {
    switch (action) {
      case "log":
        return console.log(value);
      case "configKeyEvent":
        return sendMessage({
          action: "kbdEvent",
          value: value
        });
      case "sendToDom":
        return preSendKeyEvent(value);
      case "bookmark":
        return preOpenBookmark(value);
      case "command":
        return execCommand(value);
    }
  };

  setConfigPlugin(fk.getConfig().keyConfigSet);

  scHelp = {};

  scHelpSect = {};

  scHelpPageUrl = "https://support.google.com/chrome/answer/157179?hl=";

  scrapeHelp = function(lang, sectInit, elTab) {
    var targets;
    targets = $(elTab).find("tr:has(td:first-child:has(strong))");
    return $.each(targets, function(i, elem) {
      var content;
      content = elem.cells[1].textContent.replace(/^\s+|\s$/g, "");
      return Array.prototype.forEach.call(elem.childNodes[1].getElementsByTagName("strong"), function(strong) {
        var scKey, _ref;
        scKey = strong.textContent.toUpperCase().replace(/\s/g, "");
        scKey = scKey.replace("PGUP", "PAGEUP").replace("PGDOWN", "PAGEDOWN").replace(/DEL$/, "DELETE").replace(/INS$/, "INSERT");
        if (!((_ref = scHelp[scKey]) != null ? _ref[lang] : void 0)) {
          if (!scHelp[scKey]) {
            scHelp[scKey] = {};
          }
          scHelp[scKey][lang] = [];
        }
        return scHelp[scKey][lang].push(sectInit + "^" + content);
      });
    });
  };

  analyzeScHelpPage = function(resp, lang) {
    var doc, mainSection, sectInit;
    doc = $(resp);
    mainSection = doc.find("div.main-section");
    sectInit = "";
    return Array.prototype.forEach.call(mainSection[0].children, function(el) {
      switch (el.tagName) {
        case "H3":
          switch (el.textContent) {
            case "Tab and window shortcuts":
            case "タブとウィンドウのショートカット":
              sectInit = "T";
              break;
            case "Google Chrome feature shortcuts":
            case "Google Chrome 機能のショートカット":
              sectInit = "C";
              break;
            case "Address bar shortcuts":
            case "アドレスバーのショートカット":
              sectInit = "A";
              break;
            case "Webpage shortcuts":
            case "ウェブページのショートカット":
              sectInit = "W";
              break;
            case "Text shortcuts":
            case "テキストのショートカット":
              sectInit = "Tx";
          }
          return scHelpSect[sectInit] = el.textContent;
        case "TABLE":
          return scrapeHelp(lang, sectInit, el);
      }
    });
  };

  xhr = new XMLHttpRequest();

  forecast = function(lang) {
    var dfd;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        analyzeScHelpPage(xhr.responseText, lang);
        return dfd.resolve();
      }
    };
    xhr.open("GET", scHelpPageUrl + lang, true);
    xhr.send();
    return (dfd = $.Deferred()).promise();
  };

  forecast("ja").done(function() {
    return forecast("en");
  });

}).call(this);
