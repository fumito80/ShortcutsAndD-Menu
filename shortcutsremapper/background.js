// Generated by CoffeeScript 1.6.3
(function() {
  var analyzeScHelpPage, closeTabs, execCommand, flexkbd, forecast, getActiveTab, getTabs, jsUitlObj, openBookmark, optionsTabId, preSendKeyEvent, scHelp, scHelpPageUrl, scHelpSect, scrapeHelp, sendKeyEventToDom, sendMessage, setConfigPlugin, xhr;

  window.fk = {};

  flexkbd = document.getElementById("flexkbd");

  sendMessage = function(message) {
    return chrome.tabs.query({
      active: true
    }, function(tabs) {
      return chrome.tabs.sendMessage(tabs[0].id, message);
    });
  };

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    switch (request.action) {
      case "callShortcut":
        return setTimeout((function() {
          return flexkbd.CallShortcut(request.scCode, request.msec);
        }), 0);
      case "setClipboard":
        return flexkbd.SetClipboard(request.text);
    }
  });

  /*
  triggerShortcutKey = ->
    #flexkbd.KeyEvent()
  
  chrome.contextMenus.create
    title: "「%s」をページ内検索"
    type: "normal"
    contexts: ["selection"]
    onclick: triggerShortcutKey
  */


  getActiveTab = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      return chrome.tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        return dfd.resolve(tabs[0], win.id);
      });
    });
    return dfd.promise();
  };

  getTabs = function(options) {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      options.windowId = win.id;
      return chrome.tabs.query(options, function(tabs) {
        return dfd.resolve(tabs);
      });
    });
    return dfd.promise();
  };

  optionsTabId = null;

  chrome.tabs.onActivated.addListener(function(activeInfo) {
    return chrome.tabs.get(activeInfo.tabId, function(tab) {
      if (tab.url.indexOf(chrome.extension.getURL("")) === 0) {
        flexkbd.StartConfigMode();
        return optionsTabId = activeInfo.tabId;
      } else {
        if (optionsTabId) {
          chrome.tabs.sendMessage(optionsTabId, {
            action: "saveConfig"
          });
          return optionsTabId = null;
        }
      }
    });
  });

  chrome.windows.onFocusChanged.addListener(function(windowId) {
    if (optionsTabId) {
      chrome.tabs.sendMessage(optionsTabId, {
        action: "saveConfig"
      });
      return optionsTabId = null;
    } else {
      return getActiveTab().done(function(tab) {
        if (tab.url.indexOf(chrome.extension.getURL("")) === 0) {
          flexkbd.StartConfigMode();
          return optionsTabId = tab.id;
        }
      });
    }
  });

  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    if (tab.url.indexOf(chrome.extension.getURL("")) === 0 && (changeInfo.status = "complete")) {
      return flexkbd.StartConfigMode();
    }
  });

  sendKeyEventToDom = function(keyEvent, tabId) {
    var keyIdentifier, keyIdentifiers, keys, local, modifiers, scanCode, shift;
    local = fk.getConfig();
    keys = fk.getKeyCodes()[local.config.kbdtype].keys;
    modifiers = parseInt(keyEvent.substring(0, 2), 16);
    scanCode = keyEvent.substring(2);
    keyIdentifiers = keys[scanCode];
    if (shift = (modifiers & 4) !== 0) {
      keyIdentifier = keyIdentifiers[1] || keyIdentifiers[0];
    } else {
      keyIdentifier = keyIdentifiers[0];
    }
    return chrome.tabs.sendMessage(tabId, {
      action: "keyEvent",
      keyIdentifier: keyIdentifier,
      ctrl: (modifiers & 1) !== 0,
      alt: (modifiers & 2) !== 0,
      shift: shift,
      meta: (modifiers & 8) !== 0
    });
  };

  preSendKeyEvent = function(keyEvent) {
    return chrome.tabs.query({
      active: true
    }, function(tabs) {
      var tabId;
      tabId = tabs[0].id;
      return chrome.tabs.sendMessage(tabId, {
        action: "askAlive"
      }, function(resp) {
        if (resp === "hello") {
          return sendKeyEventToDom(keyEvent, tabId);
        } else {
          return chrome.tabs.executeScript(tabId, {
            file: "kbdagent.js",
            allFrames: true
          }, function(resp) {
            return sendKeyEventToDom(keyEvent, tabId);
          });
        }
      });
    });
  };

  openBookmark = function(keyEvent) {
    var local;
    local = fk.getConfig();
    return local.keyConfigSet.forEach(function(item) {
      var url;
      if (item.proxy === keyEvent) {
        url = item.bookmark.url;
        return chrome.tabs.query({
          active: true
        }, function(tabs) {
          return chrome.tabs.update(tabs[0].id, {
            url: url
          });
        });
      }
    });
  };

  closeTabs = function(fnWhere) {
    return getTabs({
      active: false,
      currentWindow: true,
      windowType: "normal"
    }, fnWhere).done(function(tabs) {
      var tabIds;
      tabIds = [];
      tabs.forEach(function(tab) {
        if (fnWhere(tab)) {
          return tabIds.push(tab.id);
        }
      });
      if (tabIds.length > 0) {
        return chrome.tabs.remove(tabIds);
      }
    });
  };

  jsUitlObj = "scrmp = {\n  entry: function(scCode, sleepMSec) {\n    msec = 100;\n    if (sleepMSec != null) {\n      if (Number.isNaN(msec = parseInt(sleepMSec, 10))) {\n        alert(sleepMSec + \" is not a number.\");\n        return;\n      }\n    }\n    chrome.runtime.sendMessage({\n      action: \"callShortcut\",\n      scCode: scCode,\n      msec: msec\n    });\n  },\n  sleep: function(sleepMSec) {\n    this.entry(\"\", sleepMSec);\n  },\n  clipbrd: function(text) {\n    chrome.runtime.sendMessage({\n      action: \"setClipboard\",\n      text: text\n    });\n  }\n};";

  execCommand = function(keyEvent) {
    var local, pos;
    local = fk.getConfig();
    pos = 0;
    return local.keyConfigSet.forEach(function(item) {
      var code, command;
      if (item.proxy === keyEvent) {
        switch (command = item.command.name) {
          case "closeOtherTabs":
            return closeTabs(function() {
              return true;
            });
          case "closeTabsRight":
          case "closeTabsLeft":
            return getActiveTab().done(function(tab) {
              pos = tab.index;
              if (command === "closeTabsRight") {
                return closeTabs(function(tab) {
                  return tab.index > pos;
                });
              } else {
                return closeTabs(function(tab) {
                  return tab.index < pos;
                });
              }
            });
          case "moveTabRight":
          case "moveTabLeft":
            return getActiveTab().done(function(tab, windowId) {
              var newpos;
              newpos = tab.index;
              if (command === "moveTabRight") {
                newpos = newpos + 1;
              } else {
                newpos = newpos - 1;
              }
              if (newpos > -1) {
                return chrome.tabs.move(tab.id, {
                  windowId: windowId,
                  index: newpos
                });
              }
            });
          case "moveTabFirst":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 0
              });
            });
          case "moveTabLast":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 1000
              });
            });
          case "detachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.create({
                tabId: tab.id,
                focused: true,
                type: "normal"
              });
            });
          case "duplicateTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id);
            });
          case "duplicateTabWin":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function(tab) {
                return chrome.windows.create({
                  tabId: tab.id,
                  focused: true,
                  type: "normal"
                });
              });
            });
          case "pinTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.update(tab.id, {
                pinned: true
              });
            });
          case "unpinTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.update(tab.id, {
                pinned: false
              });
            });
          case "switchNextWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === windows.length - 1) {
                    chrome.windows.update(windows[0].id, {
                      focused: true
                    });
                  } else {
                    chrome.windows.update(windows[i + 1].id, {
                      focused: true
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "switchPrevWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === 0) {
                    chrome.windows.update(windows[windows.length - 1].id, {
                      focused: true
                    });
                  } else {
                    chrome.windows.update(windows[i - 1].id, {
                      focused: true
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "pasteText":
            return setTimeout((function() {
              return flexkbd.PasteText(item.command.content);
            }), 0);
          case "insertCSS":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.insertCSS(tab.id, {
                code: item.command.content,
                allFrames: item.command.allFrames
              });
            });
          case "execJS":
            code = item.command.content;
            if (item.command.useUtilObj) {
              code = jsUitlObj + code;
            }
            return getActiveTab().done(function(tab) {
              return chrome.tabs.executeScript(tab.id, {
                code: code,
                allFrames: item.command.allFrames
              });
            });
        }
      }
    });
  };

  setConfigPlugin = function(keyConfigSet) {
    var sendData;
    sendData = [];
    if (keyConfigSet) {
      keyConfigSet.forEach(function(item) {
        if (item.proxy) {
          return sendData.push([item.proxy, item.origin, item.mode].join(";"));
        }
      });
      return flexkbd.SetKeyConfig(sendData.join("|"));
    }
  };

  fk.saveConfig = function(saveData) {
    localStorage.flexkbd = JSON.stringify(saveData);
    return setConfigPlugin(saveData.keyConfigSet);
  };

  fk.getKeyCodes = function() {
    return {
      JP: {
        keys: keysJP,
        name: "JP 109 Keyboard"
      },
      US: {
        keys: keysUS,
        name: "US 104 Keyboard"
      }
    };
  };

  fk.getScHelp = function() {
    return scHelp;
  };

  fk.getScHelpSect = function() {
    return scHelpSect;
  };

  fk.getConfig = function() {
    return JSON.parse(localStorage.flexkbd || null) || {
      config: {
        kbdtype: "JP"
      }
    };
  };

  fk.startEdit = function() {
    return flexkbd.EndConfigMode();
  };

  fk.endEdit = function() {
    return flexkbd.StartConfigMode();
  };

  window.pluginEvent = function(action, value) {
    switch (action) {
      case "log":
        return console.log(value);
      case "configKeyEvent":
        return sendMessage({
          action: "kbdEvent",
          value: value
        });
      case "sendToDom":
        return preSendKeyEvent(value);
      case "bookmark":
        return openBookmark(value);
      case "command":
        return execCommand(value);
    }
  };

  setConfigPlugin(fk.getConfig().keyConfigSet);

  scHelp = {};

  scHelpSect = {};

  scHelpPageUrl = "https://support.google.com/chrome/answer/157179?hl=";

  scrapeHelp = function(lang, sectInit, elTab) {
    var targets;
    targets = $(elTab).find("tr:has(td:first-child:has(strong))");
    return $.each(targets, function(i, elem) {
      var content;
      content = elem.cells[1].textContent.replace(/^\s+|\s$/g, "");
      return Array.prototype.forEach.call(elem.childNodes[1].getElementsByTagName("strong"), function(strong) {
        var scKey, _ref;
        scKey = strong.textContent.toUpperCase().replace(/\s/g, "");
        scKey = scKey.replace("PGUP", "PAGEUP").replace("PGDOWN", "PAGEDOWN").replace(/DEL$/, "DELETE").replace(/INS$/, "INSERT");
        if (!((_ref = scHelp[scKey]) != null ? _ref[lang] : void 0)) {
          if (!scHelp[scKey]) {
            scHelp[scKey] = {};
          }
          scHelp[scKey][lang] = [];
        }
        return scHelp[scKey][lang].push(sectInit + "^" + content);
      });
    });
  };

  analyzeScHelpPage = function(resp, lang) {
    var doc, mainSection, sectInit;
    doc = $(resp);
    mainSection = doc.find("div.main-section");
    sectInit = "";
    return Array.prototype.forEach.call(mainSection[0].children, function(el) {
      switch (el.tagName) {
        case "H3":
          switch (el.textContent) {
            case "Tab and window shortcuts":
            case "タブとウィンドウのショートカット":
              sectInit = "T";
              break;
            case "Google Chrome feature shortcuts":
            case "Google Chrome 機能のショートカット":
              sectInit = "C";
              break;
            case "Address bar shortcuts":
            case "アドレスバーのショートカット":
              sectInit = "A";
              break;
            case "Webpage shortcuts":
            case "ウェブページのショートカット":
              sectInit = "W";
              break;
            case "Text shortcuts":
            case "テキストのショートカット":
              sectInit = "Tx";
          }
          return scHelpSect[sectInit] = el.textContent;
        case "TABLE":
          return scrapeHelp(lang, sectInit, el);
      }
    });
  };

  xhr = new XMLHttpRequest();

  forecast = function(lang) {
    var dfd;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        analyzeScHelpPage(xhr.responseText, lang);
        return dfd.resolve();
      }
    };
    xhr.open("GET", scHelpPageUrl + lang, true);
    xhr.send();
    return (dfd = $.Deferred()).promise();
  };

  forecast("ja").done(function() {
    return forecast("en");
  });

}).call(this);
