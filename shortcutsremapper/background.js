// Generated by CoffeeScript 1.6.3
(function() {
  var analyzeScHelpPage, closeTabs, dfdCommandQueue, execBatch, execCommand, execShortcut, flexkbd, forecast, getActiveTab, getAllTabs, getAllTabs2, getWindowTabs, jsUitlObj, notifications, openBookmark, optionsTabId, preOpenBookmark, preSendKeyEvent, scHelp, scHelpPageUrl, scHelpSect, scrapeHelp, sendKeyEventToDom, sendMessage, setClipboardWithHistory, setConfigPlugin, showCopyHistory, showNotification, xhr,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  flexkbd = document.getElementById("flexkbd");

  execShortcut = function(dfd, doneCallback, transCode, sleepMSec, execMode, batchIndex) {
    var i, item, kbdtype, keyIdentifier, keys, local, modifierChars, modifiers, modifiersCode, scCode, scanCode, test, _i, _j, _k, _ref, _ref1, _results;
    if (transCode) {
      scCode = "";
      modifiersCode = 0;
      local = fk.getConfig();
      test = transCode.match(/\[(\w*?)\](.+)/);
      if (test) {
        modifiers = RegExp.$1;
        keyIdentifier = RegExp.$2;
        modifierChars = modifiers.toLowerCase().split("");
        if ((__indexOf.call(modifierChars, "c") >= 0)) {
          modifiersCode = 1;
        }
        if ((__indexOf.call(modifierChars, "a") >= 0)) {
          modifiersCode += 2;
        }
        if ((__indexOf.call(modifierChars, "s") >= 0)) {
          modifiersCode += 4;
        }
        if ((__indexOf.call(modifierChars, "w") >= 0)) {
          modifiersCode += 8;
        }
      } else {
        modifiersCode = 0;
        keyIdentifier = transCode;
      }
      kbdtype = local.config.kbdtype;
      keys = fk.getKeyCodes()[kbdtype].keys;
      scanCode = -1;
      for (i = _i = 0, _ref = keys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (keys[i] && (keyIdentifier === keys[i][0] || keyIdentifier === keys[i][1])) {
          scanCode = i;
          break;
        }
      }
      if (scanCode === -1) {
        throw new Error("Key identifier code '" + keyIdentifier + "' is unregistered code.");
      } else {
        if (execMode !== "keydown" && modifiersCode === 0 && !(__indexOf.call((function() {
          _results = [];
          for (var _j = 0x3B; 0x3B <= 0x44 ? _j <= 0x44 : _j >= 0x44; 0x3B <= 0x44 ? _j++ : _j--){ _results.push(_j); }
          return _results;
        }).apply(this), scanCode) >= 0) && !(scanCode === 0x57 || scanCode === 0x58)) {
          throw new Error("Modifier code is not included in '" + transCode + "'.");
        } else {
          scCode = "0" + modifiersCode.toString(16) + scanCode;
        }
      }
      if (!execMode) {
        for (i = _k = 0, _ref1 = local.keyConfigSet.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
          if ((item = local.keyConfigSet[i]).proxy === scCode) {
            execMode = item.mode;
            break;
          }
        }
      }
      switch (execMode) {
        case "command":
          return execCommand(scCode).done(function() {
            return doneCallback(dfd, sleepMSec, batchIndex);
          });
        case "bookmark":
          return preOpenBookmark(scCode).done(function() {
            return doneCallback(dfd, sleepMSec, batchIndex);
          });
        case "sendToDom":
          return preSendKeyEvent(scCode).done(function() {
            return doneCallback(dfd, sleepMSec, batchIndex);
          });
        case "keydown":
          return setTimeout((function() {
            flexkbd.CallShortcut(scCode, 8);
            return doneCallback(dfd, sleepMSec, batchIndex);
          }), 0);
        default:
          return setTimeout((function() {
            flexkbd.CallShortcut(scCode, 4);
            return doneCallback(dfd, sleepMSec, batchIndex);
          }), 0);
      }
    } else {
      throw new Error("Command argument is not found.");
    }
  };

  execBatch = function(dfdCaller, request, sendResponse) {
    var commands, dfdBatchQueue, dfdKicker, doneCallback, i, _i, _ref;
    doneCallback = function(dfd, sleepMSec, batchIndex) {
      return dfd.resolve(batchIndex + 1);
    };
    (dfdBatchQueue = dfdKicker = $.Deferred()).promise();
    commands = request.value1;
    for (i = _i = 0, _ref = commands.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      dfdBatchQueue = dfdBatchQueue.then(function(batchIndex) {
        var command, dfd, e, sleepMSec;
        dfd = $.Deferred();
        try {
          if (isNaN(command = commands[batchIndex])) {
            execShortcut(dfd, doneCallback, command, 0, null, batchIndex);
          } else {
            sleepMSec = Math.round(command);
            if ((-1 < sleepMSec && sleepMSec < 60000)) {
              setTimeout((function() {
                flexkbd.Sleep(sleepMSec);
                return dfd.resolve(batchIndex + 1);
              }), 0);
            } else {
              throw new Error("Range of Sleep millisecond is up to 6000-0.");
            }
          }
        } catch (_error) {
          e = _error;
          dfd.reject();
          sendResponse(e.message);
          dfdCaller.resolve();
        }
        return dfd.promise();
      });
    }
    dfdBatchQueue = dfdBatchQueue.then(function() {
      sendResponse("done");
      return dfdCaller.resolve();
    });
    return dfdKicker.resolve(0);
  };

  dfdCommandQueue = $.Deferred().resolve();

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    var doneCallback;
    doneCallback = function(dfd, sleepMSec) {
      if (sleepMSec > 0) {
        flexkbd.Sleep(sleepMSec);
      }
      sendResponse("done");
      return dfd.resolve();
    };
    dfdCommandQueue = dfdCommandQueue.then(function() {
      var dfd, e;
      dfd = $.Deferred();
      try {
        switch (request.action) {
          case "batch":
            execBatch(dfd, request, sendResponse);
            break;
          case "callShortcut":
            execShortcut(dfd, doneCallback, request.value1, request.value2);
            break;
          case "keydown":
            execShortcut(dfd, doneCallback, request.value1, request.value2, "keydown");
            break;
          case "sleep":
            setTimeout((function() {
              flexkbd.Sleep(request.value1);
              return doneCallback(dfd, 0);
            }), 0);
            break;
          case "setClipboard":
            setTimeout((function() {
              flexkbd.SetClipboard(request.value1);
              return doneCallback(dfd, 0);
            }), 0);
        }
      } catch (_error) {
        e = _error;
        sendResponse(e.message);
        dfd.resolve();
      }
      return dfd.promise();
    });
    return true;
  });

  jsUitlObj = "var e,t,tsc;e=function(){function e(e){this.error=e}return e.prototype.done=function(e){return this},e.prototype.fail=function(e){return e(new Error(this.error)),this},e}(),t=function(){function e(){}return e.prototype.done=function(e){return this.doneCallback=e,this},e.prototype.fail=function(e){return this.failCallback=e,this},e.prototype.sendMessage=function(e,t,n,r){var i=this;return chrome.runtime.sendMessage({action:e,value1:t,value2:n,value3:r},function(e){var t;if(e===\"done\"){if(t=i.doneCallback)return setTimeout(function(){return t(e)},0)}else if(t=i.failCallback)return setTimeout(function(){return t(e)},0)}),this},e}(),tsc={batch:function(n){return n instanceof Array?(new t).sendMessage(\"batch\",n):new e(\"Argument is not Array.\")},send:function(n,r){var i;i=100;if(r!=null){if(isNaN(i=r))return new e(r+\" is not a number.\");i=Math.round(r);if(i<0||i>6e3)return new e(\"Range of Sleep millisecond is up to 6000-0.\")}return(new t).sendMessage(\"callShortcut\",n,i)},keydown:function(n,r){var i;i=100;if(r!=null){if(isNaN(i=r))return new e(r+\" is not a number.\");i=Math.round(r);if(i<0||i>6e3)return new e(\"Range of Sleep millisecond is up to 6000-0.\")}return(new t).sendMessage(\"keydown\",n,i)},sleep:function(n){if(n!=null){if(isNaN(n))return new e(n+\" is not a number.\");n=Math.round(n);if(n<0||n>6e3)return new e(\"Range of Sleep millisecond is up to 6000-0.\")}else n=100;return(new t).sendMessage(\"sleep\",n)},clipbd:function(e){return(new t).sendMessage(\"setClipboard\",e)}};";

  sendMessage = function(message) {
    return chrome.tabs.query({
      active: true
    }, function(tabs) {
      return chrome.tabs.sendMessage(tabs[0].id, message);
    });
  };

  getActiveTab = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      return chrome.tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        return dfd.resolve(tabs[0], win.id);
      });
    });
    return dfd.promise();
  };

  getWindowTabs = function(options) {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      options.windowId = win.id;
      return chrome.tabs.query(options, function(tabs) {
        return dfd.resolve(tabs);
      });
    });
    return dfd.promise();
  };

  getAllTabs = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.tabs.query({}, function(tabs) {
      return dfd.resolve(tabs);
    });
    return dfd.promise();
  };

  getAllTabs2 = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getAll({
      populate: true
    }, function(windows) {
      var tabs;
      tabs = [];
      windows.forEach(function(win) {
        return tabs = tabs.concat(win.tabs);
      });
      return dfd.resolve(tabs);
    });
    return dfd.promise();
  };

  optionsTabId = null;

  chrome.tabs.onActivated.addListener(function(activeInfo) {
    return chrome.tabs.get(activeInfo.tabId, function(tab) {
      if (tab.url.indexOf(chrome.extension.getURL("options.html")) === 0) {
        flexkbd.StartConfigMode();
        return optionsTabId = activeInfo.tabId;
      } else {
        if (optionsTabId) {
          chrome.tabs.sendMessage(optionsTabId, {
            action: "saveConfig"
          });
          return optionsTabId = null;
        }
      }
    });
  });

  chrome.windows.onFocusChanged.addListener(function(windowId) {
    if (optionsTabId) {
      chrome.tabs.sendMessage(optionsTabId, {
        action: "saveConfig"
      });
      return optionsTabId = null;
    } else {
      return getActiveTab().done(function(tab) {
        if (tab.url.indexOf(chrome.extension.getURL("")) === 0) {
          flexkbd.StartConfigMode();
          return optionsTabId = tab.id;
        }
      });
    }
  });

  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    if (tab.url.indexOf(chrome.extension.getURL("")) === 0 && (changeInfo.status = "complete")) {
      return flexkbd.StartConfigMode();
    }
  });

  notifications = {};

  notifications.state = "closed";

  chrome.notifications.onButtonClicked.addListener(function(notifId, index) {
    var copyHist;
    if (notifId === chrome.runtime.id) {
      copyHist = JSON.parse(localStorage.copyHistory || null) || [];
      flexkbd.PasteText(copyHist[index]);
      return chrome.notifications.clear(chrome.runtime.id, function() {
        return notifications.state = "closed";
      });
    }
  });

  chrome.notifications.onClosed.addListener(function(notifId, byUser) {
    if (notifId === chrome.runtime.id) {
      return notifications.state = "closed";
    }
  });

  showNotification = function() {
    var buttons, copyHist, _ref;
    copyHist = JSON.parse(localStorage.copyHistory || null) || [];
    buttons = [];
    copyHist.forEach(function(item) {
      if (item) {
        return buttons.push({
          title: item,
          message: "msg"
        });
      }
    });
    if ((_ref = notifications.state) === "opened" || _ref === "created") {
      return chrome.notifications.clear(chrome.runtime.id, function() {
        return chrome.notifications.create(chrome.runtime.id, {
          type: "list",
          iconUrl: "images/key_bindings.png",
          message: "Select text to paste",
          eventTime: 60000,
          title: "Copy history",
          items: buttons
        }, function() {
          return notifications.state = "opened";
        });
      });
    } else {
      return chrome.notifications.create(chrome.runtime.id, {
        type: "list",
        iconUrl: "images/key_bindings.png",
        message: "Select text to paste",
        eventTime: 60000,
        title: "Copy history",
        items: buttons
      }, function() {
        return notifications.state = "opened";
      });
    }
  };

  showCopyHistory = function(dfd, tabId) {
    showNotification();
    return dfd.resolve();
  };

  setClipboardWithHistory = function(dfd, tabId) {
    setTimeout((function() {
      if (dfd.state() === "pending") {
        return dfd.resolve();
      }
    }), 200);
    return chrome.tabs.sendMessage(tabId, {
      action: "copyText"
    }, function(text) {
      var copyHist, i, _i, _ref;
      if (text !== "") {
        flexkbd.SetClipboard(text);
        copyHist = JSON.parse(localStorage.copyHistory || null) || [];
        for (i = _i = 0, _ref = copyHist.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (copyHist[i] === text) {
            copyHist.splice(i, 1);
            break;
          }
        }
        copyHist.unshift(text);
        if (copyHist.length > 20) {
          copyHist.pop();
        }
        localStorage.copyHistory = JSON.stringify(copyHist);
        if (notifications.state === "opened") {
          showNotification();
        }
      }
      return dfd.resolve();
    });
  };

  sendKeyEventToDom = function(keyEvent, tabId) {
    var keyIdentifier, keyIdentifiers, keys, local, modifiers, scanCode, shift;
    local = fk.getConfig();
    keys = fk.getKeyCodes()[local.config.kbdtype].keys;
    modifiers = parseInt(keyEvent.substring(0, 2), 16);
    scanCode = keyEvent.substring(2);
    keyIdentifiers = keys[scanCode];
    if (shift = (modifiers & 4) !== 0) {
      keyIdentifier = keyIdentifiers[1] || keyIdentifiers[0];
    } else {
      keyIdentifier = keyIdentifiers[0];
    }
    return chrome.tabs.sendMessage(tabId, {
      action: "keyEvent",
      keyIdentifier: keyIdentifier,
      ctrl: (modifiers & 1) !== 0,
      alt: (modifiers & 2) !== 0,
      shift: shift,
      meta: (modifiers & 8) !== 0
    });
  };

  preSendKeyEvent = function(keyEvent) {
    var dfd;
    dfd = $.Deferred();
    getActiveTab().done(function(tab) {
      return chrome.tabs.sendMessage(tab.id, {
        action: "askAlive"
      }, function(resp) {
        if (resp === "hello") {
          sendKeyEventToDom(keyEvent, tab.id);
          return dfd.resolve();
        } else {
          return chrome.tabs.executeScript(tab.id, {
            file: "kbdagent.js",
            allFrames: true,
            runAt: "document_end"
          }, function(resp) {
            sendKeyEventToDom(keyEvent, tab.id);
            return dfd.resolve();
          });
        }
      });
    });
    return dfd.promise();
  };

  openBookmark = function(dfd, openmode, url) {
    switch (openmode) {
      case "newtab":
        return chrome.tabs.create({
          url: url
        }, function() {
          return dfd.resolve();
        });
      case "current":
        return chrome.tabs.query({
          active: true
        }, function(tabs) {
          return chrome.tabs.update(tabs[0].id, {
            url: url
          }, function() {
            return dfd.resolve();
          });
        });
      case "newwin":
        return chrome.windows.create({
          url: url
        }, function() {
          return dfd.resolve();
        });
      case "incognito":
        return chrome.windows.create({
          url: url,
          incognito: true
        }, function() {
          return dfd.resolve();
        });
      default:
        return dfd.resolve();
    }
  };

  preOpenBookmark = function(keyEvent) {
    var dfd, local;
    dfd = $.Deferred();
    local = fk.getConfig();
    local.keyConfigSet.forEach(function(item) {
      var findStr, findtab, openmode, url, _ref;
      if (item.proxy === keyEvent) {
        _ref = item.bookmark, openmode = _ref.openmode, url = _ref.url, findtab = _ref.findtab, findStr = _ref.findStr;
        if (findtab) {
          return getActiveTab().done(function(activeTab) {
            return getAllTabs().done(function(tabs) {
              var currentPos, found, i, orderedTabs, _i, _j, _ref1, _ref2;
              currentPos = 0;
              for (i = _i = 0, _ref1 = tabs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                if (tabs[i].id === activeTab.id) {
                  currentPos = i;
                  break;
                }
              }
              orderedTabs = [];
              if ((0 < currentPos && currentPos < (tabs.length - 1))) {
                orderedTabs = tabs.slice(currentPos + 1).concat(tabs.slice(0, currentPos + 1));
              } else {
                orderedTabs = tabs;
              }
              found = false;
              for (i = _j = 0, _ref2 = orderedTabs.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                if ((orderedTabs[i].title + orderedTabs[i].url).indexOf(findStr) !== -1) {
                  chrome.tabs.update(orderedTabs[i].id, {
                    active: true
                  }, function() {
                    return dfd.resolve();
                  });
                  found = true;
                  break;
                }
              }
              if (!found) {
                return openBookmark(dfd, openmode, url);
              }
            });
          });
        } else {
          return openBookmark(dfd, openmode, url);
        }
      }
    });
    return dfd.promise();
  };

  closeTabs = function(dfd, fnWhere) {
    return getWindowTabs({
      active: false,
      currentWindow: true,
      windowType: "normal"
    }, fnWhere).done(function(tabs) {
      var tabIds;
      tabIds = [];
      tabs.forEach(function(tab) {
        if (fnWhere(tab)) {
          return tabIds.push(tab.id);
        }
      });
      if (tabIds.length > 0) {
        return chrome.tabs.remove(tabIds, function() {
          return dfd.resolve();
        });
      }
    });
  };

  execCommand = function(keyEvent) {
    var dfd, local, pos;
    dfd = $.Deferred();
    local = fk.getConfig();
    pos = 0;
    local.keyConfigSet.forEach(function(item) {
      var code, command;
      if (item.proxy === keyEvent) {
        switch (command = item.command.name) {
          case "closeOtherTabs":
            return closeTabs(dfd, function() {
              return true;
            });
          case "closeTabsRight":
          case "closeTabsLeft":
            return getActiveTab().done(function(tab) {
              pos = tab.index;
              if (command === "closeTabsRight") {
                return closeTabs(dfd, function(tab) {
                  return tab.index > pos;
                });
              } else {
                return closeTabs(dfd, function(tab) {
                  return tab.index < pos;
                });
              }
            });
          case "moveTabRight":
          case "moveTabLeft":
            return getActiveTab().done(function(tab, windowId) {
              var newpos;
              newpos = tab.index;
              if (command === "moveTabRight") {
                newpos = newpos + 1;
              } else {
                newpos = newpos - 1;
              }
              if (newpos > -1) {
                return chrome.tabs.move(tab.id, {
                  windowId: windowId,
                  index: newpos
                }, function() {
                  return dfd.resolve();
                });
              }
            });
          case "moveTabFirst":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 0
              }, function() {
                return dfd.resolve();
              });
            });
          case "moveTabLast":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 1000
              }, function() {
                return dfd.resolve();
              });
            });
          case "detachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.create({
                tabId: tab.id,
                focused: true,
                type: "normal"
              }, function() {
                return dfd.resolve();
              });
            });
          case "attachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.getAll({
                populate: true
              }, function(windows) {
                var currentWindowId, i, j, newWindowId, newwin, _i, _j, _ref, _ref1;
                for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  for (j = _j = 0, _ref1 = windows[i].tabs.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                    if (tab.id === windows[i].tabs[j].id) {
                      currentWindowId = i;
                      break;
                    }
                  }
                }
                if (newwin = windows[++currentWindowId]) {
                  newWindowId = newwin.id;
                } else {
                  newWindowId = windows[0].id;
                }
                return chrome.tabs.move(tab.id, {
                  windowId: newWindowId,
                  index: 1000
                }, function() {
                  return chrome.tabs.update(tab.id, {
                    active: true
                  }, function() {
                    return dfd.resolve();
                  });
                });
              });
            });
          case "duplicateTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function() {
                return dfd.resolve();
              });
            });
          case "duplicateTabWin":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function(tab) {
                return chrome.windows.create({
                  tabId: tab.id,
                  focused: true,
                  type: "normal"
                }, function() {
                  return dfd.resolve();
                });
              });
            });
          case "pinTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.update(tab.id, {
                pinned: !tab.pinned
              }, function() {
                return dfd.resolve();
              });
            });
          case "switchNextWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === windows.length - 1) {
                    chrome.windows.update(windows[0].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  } else {
                    chrome.windows.update(windows[i + 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "switchPrevWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === 0) {
                    chrome.windows.update(windows[windows.length - 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  } else {
                    chrome.windows.update(windows[i - 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "pasteText":
            return setTimeout((function() {
              flexkbd.PasteText(item.command.content);
              return dfd.resolve();
            }), 0);
          case "copyText":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.sendMessage(tab.id, {
                action: "askAlive"
              }, function(resp) {
                if (resp === "hello") {
                  return setClipboardWithHistory(dfd, tab.id);
                } else {
                  return chrome.tabs.executeScript(tab.id, {
                    file: "kbdagent.js",
                    allFrames: true,
                    runAt: "document_end"
                  }, function(resp) {
                    return setClipboardWithHistory(dfd, tab.id);
                  });
                }
              });
            });
          case "showHistory":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.sendMessage(tab.id, {
                action: "askAlive"
              }, function(resp) {
                if (resp === "hello") {
                  return showCopyHistory(dfd, tab.id);
                } else {
                  return chrome.tabs.executeScript(tab.id, {
                    file: "kbdagent.js",
                    allFrames: true,
                    runAt: "document_end"
                  }, function(resp) {
                    return showCopyHistory(dfd, tab.id);
                  });
                }
              });
            });
          case "insertCSS":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.insertCSS(tab.id, {
                code: item.command.content,
                allFrames: item.command.allFrames
              }, function() {
                return dfd.resolve();
              });
            });
          case "execJS":
            code = item.command.content;
            if (item.command.useUtilObj) {
              code = jsUitlObj + code;
            }
            return getActiveTab().done(function(tab) {
              return chrome.tabs.executeScript(tab.id, {
                code: code,
                allFrames: item.command.allFrames,
                runAt: "document_end"
              }, function() {
                return dfd.resolve();
              });
            });
        }
      }
    });
    return dfd.promise();
  };

  setConfigPlugin = function(keyConfigSet) {
    var sendData;
    sendData = [];
    if (keyConfigSet) {
      keyConfigSet.forEach(function(item) {
        if (item.proxy) {
          return sendData.push([item.proxy, item.origin, item.mode].join(";"));
        }
      });
      return flexkbd.SetKeyConfig(sendData.join("|"));
    }
  };

  window.fk = {
    saveConfig: function(saveData) {
      localStorage.flexkbd = JSON.stringify(saveData);
      return setConfigPlugin(saveData.keyConfigSet);
    },
    getKeyCodes: function() {
      return {
        JP: {
          keys: keysJP,
          name: "JP 109 Keyboard"
        },
        US: {
          keys: keysUS,
          name: "US 104 Keyboard"
        }
      };
    },
    getScHelp: function() {
      return scHelp;
    },
    getScHelpSect: function() {
      return scHelpSect;
    },
    getConfig: function() {
      return JSON.parse(localStorage.flexkbd || null) || {
        config: {
          kbdtype: "JP"
        }
      };
    },
    startEdit: function() {
      return flexkbd.EndConfigMode();
    },
    endEdit: function() {
      return flexkbd.StartConfigMode();
    }
  };

  window.pluginEvent = function(action, value) {
    switch (action) {
      case "log":
        return console.log(value);
      case "configKeyEvent":
        return sendMessage({
          action: "kbdEvent",
          value: value
        });
      case "sendToDom":
        return preSendKeyEvent(value);
      case "bookmark":
        return preOpenBookmark(value);
      case "command":
        return execCommand(value);
    }
  };

  setConfigPlugin(fk.getConfig().keyConfigSet);

  scHelp = {};

  scHelpSect = {};

  scHelpPageUrl = "https://support.google.com/chrome/answer/157179?hl=";

  scrapeHelp = function(lang, sectInit, elTab) {
    var targets;
    targets = $(elTab).find("tr:has(td:first-child:has(strong))");
    return $.each(targets, function(i, elem) {
      var content;
      content = elem.cells[1].textContent.replace(/^\s+|\s$/g, "");
      return Array.prototype.forEach.call(elem.childNodes[1].getElementsByTagName("strong"), function(strong) {
        var scKey, _ref;
        scKey = strong.textContent.toUpperCase().replace(/\s/g, "");
        scKey = scKey.replace("PGUP", "PAGEUP").replace("PGDOWN", "PAGEDOWN").replace(/DEL$/, "DELETE").replace(/INS$/, "INSERT");
        if (!((_ref = scHelp[scKey]) != null ? _ref[lang] : void 0)) {
          if (!scHelp[scKey]) {
            scHelp[scKey] = {};
          }
          scHelp[scKey][lang] = [];
        }
        return scHelp[scKey][lang].push(sectInit + "^" + content);
      });
    });
  };

  analyzeScHelpPage = function(resp, lang) {
    var doc, mainSection, sectInit;
    doc = $(resp);
    mainSection = doc.find("div.main-section");
    sectInit = "";
    return Array.prototype.forEach.call(mainSection[0].children, function(el) {
      switch (el.tagName) {
        case "H3":
          switch (el.textContent) {
            case "Tab and window shortcuts":
            case "タブとウィンドウのショートカット":
              sectInit = "T";
              break;
            case "Google Chrome feature shortcuts":
            case "Google Chrome 機能のショートカット":
              sectInit = "C";
              break;
            case "Address bar shortcuts":
            case "アドレスバーのショートカット":
              sectInit = "A";
              break;
            case "Webpage shortcuts":
            case "ウェブページのショートカット":
              sectInit = "W";
              break;
            case "Text shortcuts":
            case "テキストのショートカット":
              sectInit = "Tx";
          }
          return scHelpSect[sectInit] = el.textContent;
        case "TABLE":
          return scrapeHelp(lang, sectInit, el);
      }
    });
  };

  xhr = new XMLHttpRequest();

  forecast = function(lang) {
    var dfd;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        analyzeScHelpPage(xhr.responseText, lang);
        return dfd.resolve();
      }
    };
    xhr.open("GET", scHelpPageUrl + lang, true);
    xhr.send();
    return (dfd = $.Deferred()).promise();
  };

  forecast("ja").done(function() {
    return forecast("en");
  });

}).call(this);
