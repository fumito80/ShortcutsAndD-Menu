// Generated by CoffeeScript 1.6.3
(function() {
  var analyzeScHelpPage, closeTabs, closeWindow, createCtxMenus, defaultSleep, deleteHistory, dfdCommandQueue, execBatch, execBatchMode, execCommand, execCtxMenu, execShortcut, flexkbd, getActiveTab, getAllTabs, getAllTabs2, getWindowTabs, jsCtxData, jsUtilObj, modifierInits, notifications, openBookmark, optionsTabId, preOpenBookmark, registerCtxMenu, removeCookie, scHelp, scHelpPageUrl, scHelpSect, scrapeHelp, sendMessage, setClipboardWithHistory, setConfigPlugin, showCopyHistory, showNotification, tabStateNotifier, transKbdEvent,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  defaultSleep = 100;

  flexkbd = document.getElementById("flexkbd");

  tabStateNotifier = {
    callbacks: {},
    completes: {},
    reset: function(tabId) {
      return this.completes[tabId] = false;
    },
    register: function(tabId, callback) {
      if (this.completes[tabId]) {
        return callback();
      } else {
        return this.callbacks[tabId] = callback;
      }
    },
    callComplete: function(tabId) {
      var callback;
      if (callback = this.callbacks[tabId]) {
        return callback();
      } else {
        return this.completes[tabId] = true;
      }
    }
  };

  execShortcut = function(dfd, doneCallback, transCode, scCode, sleepMSec, execMode, batchIndex) {
    var i, item, kbdtype, keyIdentifier, keys, modifierChars, modifiers, modifiersCode, scanCode, test, _i, _j, _k, _ref, _ref1, _results;
    if (transCode) {
      modifiersCode = 0;
      test = transCode.match(/\[(\w*?)\](.+)/);
      if (test) {
        modifiers = RegExp.$1;
        keyIdentifier = RegExp.$2;
        modifierChars = modifiers.toLowerCase().split("");
        if ((__indexOf.call(modifierChars, "c") >= 0)) {
          modifiersCode = 1;
        }
        if ((__indexOf.call(modifierChars, "a") >= 0)) {
          modifiersCode += 2;
        }
        if ((__indexOf.call(modifierChars, "s") >= 0)) {
          modifiersCode += 4;
        }
        if ((__indexOf.call(modifierChars, "w") >= 0)) {
          modifiersCode += 8;
        }
      } else {
        modifiersCode = 0;
        keyIdentifier = transCode;
      }
      kbdtype = andy.local.config.kbdtype;
      keys = andy.getKeyCodes()[kbdtype].keys;
      scanCode = -1;
      for (i = _i = 0, _ref = keys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (keys[i] && (keyIdentifier === keys[i][0] || keyIdentifier === keys[i][1])) {
          scanCode = i;
          break;
        }
      }
      if (scanCode === -1) {
        throw new Error("Key identifier code '" + keyIdentifier + "' is unregistered code.");
      } else {
        if (execMode !== "keydown" && modifiersCode === 0 && !(__indexOf.call((function() {
          _results = [];
          for (var _j = 0x3B; 0x3B <= 0x44 ? _j <= 0x44 : _j >= 0x44; 0x3B <= 0x44 ? _j++ : _j--){ _results.push(_j); }
          return _results;
        }).apply(this), scanCode) >= 0) && !(scanCode === 0x57 || scanCode === 0x58)) {
          throw new Error("Modifier code is not included in '" + transCode + "'.");
        } else {
          scCode = "0" + modifiersCode.toString(16) + scanCode;
        }
      }
    } else if (!scCode) {
      throw new Error("Command argument is not found.");
      return;
    }
    if (!execMode) {
      for (i = _k = 0, _ref1 = andy.local.keyConfigSet.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        if ((item = andy.local.keyConfigSet[i])["new"] === scCode) {
          execMode = item.mode;
          break;
        }
      }
    }
    switch (execMode) {
      case "command":
        return execCommand(scCode).done(function() {
          return doneCallback(dfd, sleepMSec, batchIndex);
        });
      case "bookmark":
        return preOpenBookmark(scCode).done(function(tabId) {
          if (tabId) {
            return tabStateNotifier.register(tabId, function() {
              return doneCallback(dfd, sleepMSec, batchIndex);
            });
          } else {
            return doneCallback(dfd, sleepMSec, batchIndex);
          }
        });
      case "keydown":
        return setTimeout((function() {
          flexkbd.CallShortcut(scCode, 8);
          return doneCallback(dfd, sleepMSec, batchIndex);
        }), 0);
      default:
        return setTimeout((function() {
          flexkbd.CallShortcut(scCode, 4);
          return doneCallback(dfd, sleepMSec, batchIndex);
        }), 0);
    }
  };

  execBatch = function(dfdCaller, request, sendResponse) {
    var commands, dfdBatchQueue, dfdKicker, doneCallback, i, _i, _ref;
    doneCallback = function(dfd, sleepMSec, batchIndex) {
      return dfd.resolve(batchIndex + 1);
    };
    (dfdBatchQueue = dfdKicker = $.Deferred()).promise();
    commands = request.value1;
    for (i = _i = 0, _ref = commands.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      dfdBatchQueue = dfdBatchQueue.then(function(batchIndex) {
        var command, dfd, e, sleepMSec;
        dfd = $.Deferred();
        try {
          if (isNaN(command = commands[batchIndex])) {
            execShortcut(dfd, doneCallback, command, null, 0, null, batchIndex);
          } else {
            sleepMSec = Math.round(command);
            if ((-1 < sleepMSec && sleepMSec < 60000)) {
              setTimeout((function() {
                flexkbd.Sleep(sleepMSec);
                return dfd.resolve(batchIndex + 1);
              }), 0);
            } else {
              throw new Error("Range of Sleep millisecond is up to 6000-0.");
            }
          }
        } catch (_error) {
          e = _error;
          dfd.reject();
          sendResponse({
            msg: e.message
          });
          dfdCaller.resolve();
        }
        return dfd.promise();
      });
    }
    dfdBatchQueue = dfdBatchQueue.then(function() {
      sendResponse({
        msg: "done"
      });
      return dfdCaller.resolve();
    });
    return dfdKicker.resolve(0);
  };

  modifierInits = ["c", "a", "s", "w"];

  transKbdEvent = function(value, kbdtype) {
    var i, keyCombo, keyIdenfiers, keys, modifiers, scanCode, _i, _ref;
    keys = andy.getKeyCodes()[kbdtype].keys;
    modifiers = parseInt(value.substring(0, 2), 16);
    keyCombo = [];
    for (i = _i = 0, _ref = modifierInits.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (modifiers & Math.pow(2, i)) {
        keyCombo.push(modifierInits[i]);
      }
    }
    scanCode = value.substring(2);
    keyIdenfiers = keys[scanCode];
    return "[" + keyCombo.join("") + "]" + keyIdenfiers[0];
  };

  jsCtxData = "";

  execCtxMenu = function(info) {
    var i, keyConfig, _i, _ref, _results;
    jsCtxData = "tsc.ctxData = '" + (info.selectionText || info.linkUrl || info.srcUrl || info.pageUrl || "").replace(/'/g, "\\'") + "';";
    _results = [];
    for (i = _i = 0, _ref = andy.local.keyConfigSet.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if ((keyConfig = andy.local.keyConfigSet[i])["new"] === info.menuItemId) {
        execBatchMode(keyConfig["new"]);
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  chrome.contextMenus.onClicked.addListener(function(info, tab) {
    return execCtxMenu(info);
  });

  dfdCommandQueue = $.Deferred().resolve();

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    var doneCallback;
    doneCallback = function(dfd, sleepMSec) {
      if (sleepMSec > 0) {
        flexkbd.Sleep(sleepMSec);
      }
      sendResponse({
        msg: "done"
      });
      return dfd.resolve();
    };
    dfdCommandQueue = dfdCommandQueue.then(function() {
      var dfd, e;
      dfd = $.Deferred();
      setTimeout((function() {
        if (dfd.state() === "pending") {
          sendResponse({
            msg: "Command has been killed in a time-out."
          });
          return dfd.resolve();
        }
      }), 61000);
      try {
        switch (request.action) {
          case "batch":
            execBatch(dfd, request, sendResponse);
            break;
          case "callShortcut":
            execShortcut(dfd, doneCallback, request.value1, null, request.value2);
            break;
          case "keydown":
            execShortcut(dfd, doneCallback, request.value1, null, request.value2, "keydown");
            break;
          case "sleep":
            setTimeout((function() {
              flexkbd.Sleep(request.value1);
              return doneCallback(dfd, 0);
            }), 0);
            break;
          case "setClipboard":
            setTimeout((function() {
              flexkbd.SetClipboard(request.value1);
              return doneCallback(dfd, 0);
            }), 0);
            break;
          case "getClipboard":
            setTimeout((function() {
              var e, result, text;
              try {
                text = flexkbd.GetClipboard();
                result = "done";
              } catch (_error) {
                e = _error;
                text = "";
                result = e.message;
              }
              sendResponse({
                msg: result,
                text: text
              });
              return dfd.resolve();
            }), 0);
        }
      } catch (_error) {
        e = _error;
        sendResponse({
          msg: e.message
        });
        dfd.resolve();
      }
      return dfd.promise();
    });
    return true;
  });

  jsUtilObj = "var e,t,tsc;e=function(){function e(e){this.error=e}return e.prototype.done=function(e){return this},e.prototype.fail=function(e){return e(new Error(this.error)),this},e}(),t=function(){function e(){}return e.prototype.done=function(e){return this.doneCallback=e,this},e.prototype.fail=function(e){return this.failCallback=e,this},e.prototype.sendMessage=function(e,t,n,r){var i=this;return chrome.runtime.sendMessage({action:e,value1:t,value2:n,value3:r},function(e){var t;if((e!=null?e.msg:void 0)===\"done\"){if(t=i.doneCallback)return setTimeout(function(){return t(e.text||e.msg)},0)}else if(t=i.failCallback)return setTimeout(function(){return t(e.msg)},0)}),this},e}(),tsc={batch:function(n){return n instanceof Array?(new t).sendMessage(\"batch\",n):new e(\"Argument is not Array.\")},send:function(n,r){var i;i=100;if(r!=null){if(isNaN(i=r))return new e(r+\" is not a number.\");i=Math.round(r);if(i<0||i>6e3)return new e(\"Range of Sleep millisecond is up to 6000-0.\")}return(new t).sendMessage(\"callShortcut\",n,i)},keydown:function(n,r){var i;i=100;if(r!=null){if(isNaN(i=r))return new e(r+\" is not a number.\");i=Math.round(r);if(i<0||i>6e3)return new e(\"Range of Sleep millisecond is up to 6000-0.\")}return(new t).sendMessage(\"keydown\",n,i)},sleep:function(n){if(n!=null){if(isNaN(n))return new e(n+\" is not a number.\");n=Math.round(n);if(n<0||n>6e3)return new e(\"Range of Sleep millisecond is up to 6000-0.\")}else n=100;return(new t).sendMessage(\"sleep\",n)},clipbd:function(e){return(new t).sendMessage(\"setClipboard\",e)},getClipbd:function(){return(new t).sendMessage(\"getClipboard\")}};";

  sendMessage = function(message) {
    return chrome.tabs.query({
      active: true
    }, function(tabs) {
      return chrome.tabs.sendMessage(tabs[0].id, message);
    });
  };

  getActiveTab = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      return chrome.tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        return dfd.resolve(tabs[0], win.id);
      });
    });
    return dfd.promise();
  };

  getWindowTabs = function(options) {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getCurrent(null, function(win) {
      options.windowId = win.id;
      return chrome.tabs.query(options, function(tabs) {
        return dfd.resolve(tabs);
      });
    });
    return dfd.promise();
  };

  getAllTabs = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.tabs.query({}, function(tabs) {
      return dfd.resolve(tabs);
    });
    return dfd.promise();
  };

  getAllTabs2 = function() {
    var dfd;
    dfd = $.Deferred();
    chrome.windows.getAll({
      populate: true
    }, function(windows) {
      var tabs;
      tabs = [];
      windows.forEach(function(win) {
        return tabs = tabs.concat(win.tabs);
      });
      return dfd.resolve(tabs);
    });
    return dfd.promise();
  };

  optionsTabId = null;

  chrome.tabs.onActivated.addListener(function(activeInfo) {
    return chrome.tabs.get(activeInfo.tabId, function(tab) {
      if (tab.url.indexOf(chrome.extension.getURL("options.html")) === 0) {
        flexkbd.StartConfigMode();
        return optionsTabId = activeInfo.tabId;
      } else {
        if (optionsTabId) {
          chrome.tabs.sendMessage(optionsTabId, {
            action: "saveConfig"
          });
          return optionsTabId = null;
        }
      }
    });
  });

  chrome.windows.onFocusChanged.addListener(function(windowId) {
    if (optionsTabId) {
      chrome.tabs.sendMessage(optionsTabId, {
        action: "saveConfig"
      });
      return optionsTabId = null;
    } else {
      return getActiveTab().done(function(tab) {
        if (tab.url.indexOf(chrome.extension.getURL("options.html")) === 0) {
          flexkbd.StartConfigMode();
          return optionsTabId = tab.id;
        }
      });
    }
  });

  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    if (changeInfo.status === "complete") {
      if (tab.url.indexOf(chrome.extension.getURL("options.html")) === 0) {
        return flexkbd.StartConfigMode();
      } else {
        return tabStateNotifier.callComplete(tabId);
      }
    }
  });

  execBatchMode = function(scCode) {
    var dfdBatchQueue, dfdKicker, doneCallback, i, keyConfigs, _i, _ref;
    doneCallback = function(dfd, sleepMSec, batchIndex) {
      if (sleepMSec > 0) {
        flexkbd.Sleep(sleepMSec);
      }
      return dfd.resolve(batchIndex + 1);
    };
    keyConfigs = [];
    andy.local.keyConfigSet.forEach(function(keyConfig) {
      if (keyConfig["new"] === scCode || keyConfig.parentId === scCode) {
        return keyConfigs.push(keyConfig);
      }
    });
    (dfdBatchQueue = dfdKicker = $.Deferred()).promise();
    for (i = _i = 0, _ref = keyConfigs.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      dfdBatchQueue = dfdBatchQueue.then(function(batchIndex) {
        var dfd, e, keyConfig;
        dfd = $.Deferred();
        setTimeout((function() {
          if (dfd.state() === "pending") {
            dfd.reject();
            return console.log("Command has been killed in a time-out.");
          }
        }), 61000);
        try {
          keyConfig = keyConfigs[batchIndex];
          switch (keyConfig.mode) {
            case "remap":
              execShortcut(dfd, doneCallback, null, keyConfig.origin, defaultSleep, "keydown", batchIndex);
              break;
            case "sleep":
              setTimeout((function() {
                flexkbd.Sleep(~~keyConfig.sleep);
                return doneCallback(dfd, 0, batchIndex);
              }), 0);
              break;
            case "comment":
              setTimeout((function() {
                return doneCallback(dfd, 0, batchIndex);
              }), 0);
              break;
            default:
              execShortcut(dfd, doneCallback, null, keyConfig["new"], defaultSleep, keyConfig.mode, batchIndex);
          }
        } catch (_error) {
          e = _error;
          dfd.reject();
          console.log(e.message);
        }
        return dfd.promise();
      });
    }
    return dfdKicker.resolve(0);
  };

  notifications = {};

  notifications.state = "closed";

  chrome.notifications.onButtonClicked.addListener(function(notifId, index) {
    var copyHist;
    if (notifId === chrome.runtime.id) {
      copyHist = JSON.parse(localStorage.copyHistory || null) || [];
      flexkbd.PasteText(copyHist[index]);
      return chrome.notifications.clear(chrome.runtime.id, function() {
        return notifications.state = "closed";
      });
    }
  });

  chrome.notifications.onClosed.addListener(function(notifId, byUser) {
    if (notifId === chrome.runtime.id) {
      return notifications.state = "closed";
    }
  });

  showNotification = function() {
    var buttons, copyHist, _ref;
    copyHist = JSON.parse(localStorage.copyHistory || null) || [];
    buttons = [];
    copyHist.forEach(function(item) {
      if (item) {
        return buttons.push({
          title: item,
          message: "msg"
        });
      }
    });
    if ((_ref = notifications.state) === "opened" || _ref === "created") {
      return chrome.notifications.clear(chrome.runtime.id, function() {
        return chrome.notifications.create(chrome.runtime.id, {
          type: "list",
          iconUrl: "images/key_bindings.png",
          message: "Select text to paste",
          eventTime: 60000,
          title: "Copy history",
          items: buttons
        }, function() {
          return notifications.state = "opened";
        });
      });
    } else {
      return chrome.notifications.create(chrome.runtime.id, {
        type: "list",
        iconUrl: "images/key_bindings.png",
        message: "Select text to paste",
        eventTime: 60000,
        title: "Copy history",
        items: buttons
      }, function() {
        return notifications.state = "opened";
      });
    }
  };

  showCopyHistory = function(dfd, tabId) {
    showNotification();
    return dfd.resolve();
  };

  setClipboardWithHistory = function(dfd, tabId) {
    setTimeout((function() {
      if (dfd.state() === "pending") {
        return dfd.resolve();
      }
    }), 200);
    return chrome.tabs.sendMessage(tabId, {
      action: "copyText"
    }, function(text) {
      var copyHist, i, _i, _ref;
      if (text !== "") {
        flexkbd.SetClipboard(text);
        copyHist = JSON.parse(localStorage.copyHistory || null) || [];
        for (i = _i = 0, _ref = copyHist.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (copyHist[i] === text) {
            copyHist.splice(i, 1);
            break;
          }
        }
        copyHist.unshift(text);
        if (copyHist.length > 20) {
          copyHist.pop();
        }
        localStorage.copyHistory = JSON.stringify(copyHist);
        if (notifications.state === "opened") {
          showNotification();
        }
      }
      return dfd.resolve();
    });
  };

  openBookmark = function(dfd, openmode, url) {
    switch (openmode) {
      case "newtab":
        return chrome.tabs.create({
          url: url
        }, function(tab) {
          return dfd.resolve(tab.id);
        });
      case "current":
        return chrome.tabs.query({
          active: true
        }, function(tabs) {
          tabStateNotifier.reset(tabs[0].id);
          return chrome.tabs.update(tabs[0].id, {
            url: url
          }, function(tab) {
            return dfd.resolve(tab.id);
          });
        });
      case "newwin":
        return chrome.windows.create({
          url: url
        }, function(tab) {
          return dfd.resolve(tab.id);
        });
      case "incognito":
        return chrome.windows.create({
          url: url,
          incognito: true
        }, function(tab) {
          return dfd.resolve(tab.id);
        });
      default:
        return dfd.resolve();
    }
  };

  preOpenBookmark = function(keyEvent) {
    var dfd;
    dfd = $.Deferred();
    andy.local.keyConfigSet.forEach(function(item) {
      var findStr, findtab, openmode, url, _ref;
      if (item["new"] === keyEvent) {
        _ref = item.bookmark, openmode = _ref.openmode, url = _ref.url, findtab = _ref.findtab, findStr = _ref.findStr;
        if (findtab || openmode === "findonly") {
          return getActiveTab().done(function(activeTab) {
            return getAllTabs().done(function(tabs) {
              var currentPos, found, i, orderedTabs, _i, _j, _ref1, _ref2;
              currentPos = 0;
              for (i = _i = 0, _ref1 = tabs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                if (tabs[i].id === activeTab.id) {
                  currentPos = i;
                  break;
                }
              }
              orderedTabs = [];
              if ((0 < currentPos && currentPos < (tabs.length - 1))) {
                orderedTabs = tabs.slice(currentPos + 1).concat(tabs.slice(0, currentPos + 1));
              } else {
                orderedTabs = tabs;
              }
              found = false;
              for (i = _j = 0, _ref2 = orderedTabs.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                if ((orderedTabs[i].title + orderedTabs[i].url).indexOf(findStr) !== -1) {
                  chrome.tabs.update(orderedTabs[i].id, {
                    active: true
                  }, function() {
                    return dfd.resolve();
                  });
                  found = true;
                  break;
                }
              }
              if (!found) {
                return openBookmark(dfd, openmode, url);
              }
            });
          });
        } else {
          return openBookmark(dfd, openmode, url);
        }
      }
    });
    return dfd.promise();
  };

  removeCookie = function(dfd, removeSpecs, index) {
    var removeSpec;
    if (removeSpec = removeSpecs[index]) {
      return chrome.cookies.remove({
        "url": removeSpec.url,
        "name": removeSpec.name
      }, function() {
        return removeCookie(dfd, removeSpecs, index + 1);
      });
    } else {
      return dfd.resolve();
    }
  };

  deleteHistory = function(dfd, deleteUrls, index) {
    var url;
    if (url = deleteUrls[index]) {
      return chrome.history.deleteUrl({
        url: url
      }, function() {
        return deleteHistory(dfd, deleteUrls, index + 1);
      });
    } else {
      return dfd.resolve();
    }
  };

  closeWindow = function(dfd, windows, index) {
    var win;
    if (win = windows[index]) {
      if (win.focused) {
        return closeWindow(dfd, windows, index + 1);
      } else {
        return chrome.windows.remove(win.id, function() {
          return closeWindow(dfd, windows, index + 1);
        });
      }
    } else {
      return dfd.resolve();
    }
  };

  closeTabs = function(dfd, fnWhere) {
    return getWindowTabs({
      active: false,
      currentWindow: true,
      windowType: "normal"
    }, fnWhere).done(function(tabs) {
      var tabIds;
      tabIds = [];
      tabs.forEach(function(tab) {
        if (fnWhere(tab)) {
          return tabIds.push(tab.id);
        }
      });
      if (tabIds.length > 0) {
        return chrome.tabs.remove(tabIds, function() {
          return dfd.resolve();
        });
      } else {
        return dfd.resolve();
      }
    });
  };

  execCommand = function(keyEvent) {
    var dfd, pos;
    dfd = $.Deferred();
    pos = 0;
    andy.local.keyConfigSet.forEach(function(item) {
      var code, command, findStr;
      if (item["new"] === keyEvent) {
        switch (command = item.command.name) {
          case "createTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.create({
                windowId: windowId,
                index: tab.index + 1
              }, function(tab) {
                return tabStateNotifier.register(tab.id, function() {
                  return dfd.resolve();
                });
              });
            });
          case "createTabBG":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.create({
                windowId: windowId,
                index: tab.index + 1,
                active: false
              }, function(tab) {
                return tabStateNotifier.register(tab.id, function() {
                  return dfd.resolve();
                });
              });
            });
          case "closeOtherTabs":
            return closeTabs(dfd, function() {
              return true;
            });
          case "closeTabsRight":
          case "closeTabsLeft":
            return getActiveTab().done(function(tab) {
              pos = tab.index;
              if (command === "closeTabsRight") {
                return closeTabs(dfd, function(tab) {
                  return tab.index > pos;
                });
              } else {
                return closeTabs(dfd, function(tab) {
                  return tab.index < pos;
                });
              }
            });
          case "moveTabRight":
          case "moveTabLeft":
            return getActiveTab().done(function(tab, windowId) {
              var newpos;
              newpos = tab.index;
              if (command === "moveTabRight") {
                newpos = newpos + 1;
              } else {
                newpos = newpos - 1;
              }
              if (newpos > -1) {
                return chrome.tabs.move(tab.id, {
                  windowId: windowId,
                  index: newpos
                }, function() {
                  return dfd.resolve();
                });
              } else {
                return dfd.resolve();
              }
            });
          case "moveTabFirst":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 0
              }, function() {
                return dfd.resolve();
              });
            });
          case "moveTabLast":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.move(tab.id, {
                windowId: windowId,
                index: 1000
              }, function() {
                return dfd.resolve();
              });
            });
          case "detachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.create({
                tabId: tab.id,
                focused: true,
                type: "normal"
              }, function() {
                return dfd.resolve();
              });
            });
          case "attachTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.windows.getAll({
                populate: true
              }, function(windows) {
                var currentWindowId, i, j, newWindowId, newwin, _i, _j, _ref, _ref1;
                for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  for (j = _j = 0, _ref1 = windows[i].tabs.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                    if (tab.id === windows[i].tabs[j].id) {
                      currentWindowId = i;
                      break;
                    }
                  }
                }
                if (newwin = windows[++currentWindowId]) {
                  newWindowId = newwin.id;
                } else {
                  newWindowId = windows[0].id;
                }
                return chrome.tabs.move(tab.id, {
                  windowId: newWindowId,
                  index: 1000
                }, function() {
                  return chrome.tabs.update(tab.id, {
                    active: true
                  }, function() {
                    return dfd.resolve();
                  });
                });
              });
            });
          case "duplicateTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function() {
                return dfd.resolve();
              });
            });
          case "duplicateTabWin":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.duplicate(tab.id, function(tab) {
                return chrome.windows.create({
                  tabId: tab.id,
                  focused: true,
                  type: "normal"
                }, function() {
                  return dfd.resolve();
                });
              });
            });
          case "pinTab":
            return getActiveTab().done(function(tab, windowId) {
              return chrome.tabs.update(tab.id, {
                pinned: !tab.pinned
              }, function() {
                return dfd.resolve();
              });
            });
          case "switchNextWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === windows.length - 1) {
                    chrome.windows.update(windows[0].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  } else {
                    chrome.windows.update(windows[i + 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "switchPrevWin":
            return chrome.windows.getAll(null, function(windows) {
              var i, _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = windows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (windows[i].focused) {
                  if (i === 0) {
                    chrome.windows.update(windows[windows.length - 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  } else {
                    chrome.windows.update(windows[i - 1].id, {
                      focused: true
                    }, function() {
                      return dfd.resolve();
                    });
                  }
                  break;
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            });
          case "closeOtherWins":
            return chrome.windows.getAll(null, function(windows) {
              return closeWindow(dfd, windows, 0);
            });
          case "pasteText":
            return setTimeout((function() {
              flexkbd.PasteText(item.command.content);
              return dfd.resolve();
            }), 0);
          case "copyText":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.sendMessage(tab.id, {
                action: "askAlive"
              }, function(resp) {
                if (resp === "hello") {
                  return setClipboardWithHistory(dfd, tab.id);
                } else {
                  return chrome.tabs.executeScript(tab.id, {
                    file: "kbdagent.js",
                    allFrames: true,
                    runAt: "document_end"
                  }, function(resp) {
                    return setClipboardWithHistory(dfd, tab.id);
                  });
                }
              });
            });
          case "showHistory":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.sendMessage(tab.id, {
                action: "askAlive"
              }, function(resp) {
                if (resp === "hello") {
                  return showCopyHistory(dfd, tab.id);
                } else {
                  return chrome.tabs.executeScript(tab.id, {
                    file: "kbdagent.js",
                    allFrames: true,
                    runAt: "document_end"
                  }, function(resp) {
                    return showCopyHistory(dfd, tab.id);
                  });
                }
              });
            });
          case "insertCSS":
            return getActiveTab().done(function(tab) {
              return chrome.tabs.insertCSS(tab.id, {
                code: item.command.content,
                allFrames: item.command.allFrames
              }, function() {
                return dfd.resolve();
              });
            });
          case "execJS":
            code = item.command.content;
            if (item.command.useUtilObj) {
              code = jsUtilObj + jsCtxData + code;
            }
            return getActiveTab().done(function(tab) {
              return chrome.tabs.executeScript(tab.id, {
                code: code,
                allFrames: item.command.allFrames,
                runAt: "document_end"
              }, function() {
                return dfd.resolve();
              });
            });
          case "clearHistory":
            return chrome.browsingData.removeHistory({}, function() {
              return dfd.resolve();
            });
          case "clearHistoryS":
            findStr = item.command.content;
            return chrome.history.search({
              text: "",
              startTime: 0,
              maxResults: 10000
            }, function(histories) {
              var deleteUrls, history, i, _i, _ref;
              deleteUrls = [];
              for (i = _i = 0, _ref = histories.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                history = histories[i];
                if ((history.title + history.url).indexOf(findStr) !== -1) {
                  deleteUrls.push(history.url);
                }
              }
              if (deleteUrls.length > 0) {
                return deleteHistory(dfd, deleteUrls, 0);
              }
            });
          case "clearCookiesAll":
            return chrome.browsingData.removeCookies({}, function() {
              return dfd.resolve();
            });
          case "clearCookies":
            return getActiveTab().done(function(tab) {
              var domain, removeSpecs;
              domain = tab.url.match(/:\/\/(.[^/:]+)/)[1];
              removeSpecs = [];
              return chrome.cookies.getAll({}, function(cookies) {
                cookies.forEach(function(cookie) {
                  var secure, url;
                  if (("." + domain).indexOf(cookie.domain) !== -1) {
                    secure = cookie.secure ? "s" : "";
                    url = ("http" + secure + "://") + cookie.domain + cookie.path;
                    return removeSpecs.push({
                      "url": url,
                      "name": cookie.name
                    });
                  }
                });
                return removeCookie(dfd, removeSpecs, 0);
              });
            });
          case "clearCache":
            return chrome.browsingData.removeCache({}, function() {
              return dfd.resolve();
            });
        }
      }
    });
    return dfd.promise();
  };

  setConfigPlugin = function(keyConfigSet) {
    var sendData;
    sendData = [];
    if (keyConfigSet) {
      keyConfigSet.forEach(function(item) {
        if (item.batch && item["new"]) {
          return sendData.push([item["new"], item.origin, "batch"].join(";"));
        } else if (!/^C/.test(item["new"])) {
          return sendData.push([item["new"], item.origin, item.mode].join(";"));
        }
      });
      return flexkbd.SetKeyConfig(sendData.join("|"));
    }
  };

  window.andy = {
    local: null,
    setLocal: function() {
      var dfd,
        _this = this;
      dfd = $.Deferred();
      chrome.storage.local.get(null, function(items) {
        if (!items.config) {
          items.config = {
            kbdtype: "JP"
          };
        }
        if (!items.ctxMenuFolderSet) {
          items.ctxMenuFolderSet = [];
        }
        _this.local = items;
        return dfd.resolve();
      });
      return dfd.promise();
    },
    saveConfig: function(saveData) {
      var _this = this;
      return chrome.storage.local.set(saveData, function() {
        _this.local = saveData;
        return setConfigPlugin(_this.local.keyConfigSet);
      });
    },
    remakeCtxMenu: function(saveData) {
      var dfd,
        _this = this;
      dfd = $.Deferred();
      chrome.storage.local.set(saveData, function() {
        _this.local = saveData;
        return createCtxMenus().done(function() {
          return dfd.resolve();
        });
      });
      return dfd.promise();
    },
    getKeyCodes: function() {
      return {
        JP: {
          keys: keysJP,
          name: "JP 109 Keyboard"
        },
        US: {
          keys: keysUS,
          name: "US 104 Keyboard"
        }
      };
    },
    getScHelp: function() {
      return scHelp;
    },
    getScHelpSect: function() {
      return scHelpSect;
    },
    startEdit: function() {
      return flexkbd.EndConfigMode();
    },
    endEdit: function() {
      return flexkbd.StartConfigMode();
    },
    getCtxMenus: function() {}
  };

  window.pluginEvent = function(action, value) {
    switch (action) {
      case "log":
        return console.log(value);
      case "configKeyEvent":
        return sendMessage({
          action: "kbdEvent",
          value: value
        });
      case "bookmark":
        return preOpenBookmark(value);
      case "command":
        return execCommand(value);
      case "batch":
        return execBatchMode(value);
    }
  };

  scHelp = {};

  scHelpSect = {};

  scHelpPageUrl = "https://support.google.com/chrome/answer/157179?hl=";

  scrapeHelp = function(lang, sectInit, elTab) {
    var targets;
    targets = $(elTab).find("tr:has(td:first-child:has(strong))");
    return $.each(targets, function(i, elem) {
      var content;
      content = elem.cells[1].textContent.replace(/^\s+|\s$/g, "");
      return Array.prototype.forEach.call(elem.childNodes[1].getElementsByTagName("strong"), function(strong) {
        var scKey, _ref;
        scKey = strong.textContent.toUpperCase().replace(/\s/g, "");
        scKey = scKey.replace("PGUP", "PAGEUP").replace("PGDOWN", "PAGEDOWN").replace(/DEL$/, "DELETE").replace(/INS$/, "INSERT").replace("ホーム", "HOME").replace("バー", "");
        if (!((_ref = scHelp[scKey]) != null ? _ref[lang] : void 0)) {
          if (!scHelp[scKey]) {
            scHelp[scKey] = {};
          }
          scHelp[scKey][lang] = [];
        }
        return scHelp[scKey][lang].push(sectInit + "^" + content);
      });
    });
  };

  analyzeScHelpPage = function(resp, lang) {
    var doc, mainSection, sectInit;
    doc = $(resp);
    mainSection = doc.find("div.main-section");
    sectInit = "";
    return Array.prototype.forEach.call(mainSection[0].children, function(el) {
      switch (el.tagName) {
        case "H3":
          switch (el.textContent) {
            case "Tab and window shortcuts":
            case "タブとウィンドウのショートカット":
              sectInit = "T";
              break;
            case "Google Chrome feature shortcuts":
            case "Google Chrome 機能のショートカット":
              sectInit = "C";
              break;
            case "Address bar shortcuts":
            case "アドレスバーのショートカット":
              sectInit = "A";
              break;
            case "Webpage shortcuts":
            case "ウェブページのショートカット":
              sectInit = "W";
              break;
            case "Text shortcuts":
            case "テキストのショートカット":
              sectInit = "Tx";
          }
          return scHelpSect[sectInit] = el.textContent;
        case "TABLE":
          return scrapeHelp(lang, sectInit, el);
      }
    });
  };

  registerCtxMenu = function(dfd, ctxMenus, index) {
    var caption, contexts, ctxData, ctxMenu, id, parentId, type, _ref;
    if (ctxMenu = ctxMenus[index]) {
      _ref = ctxMenus[index], id = _ref.id, type = _ref.type, caption = _ref.caption, contexts = _ref.contexts, parentId = _ref.parentId;
      if (/pause/.test(type)) {
        ctxData = {
          type: "normal",
          enabled: false
        };
      } else {
        ctxData = {
          type: "normal",
          enabled: true
        };
      }
      if (caption) {
        ctxData.title = caption;
        ctxData.contexts = [contexts];
      }
      if (parentId !== "route") {
        ctxData.parentId = parentId;
      }
      if (/create/.test(type)) {
        ctxData.id = id;
        return chrome.contextMenus.create(ctxData, function() {
          return registerCtxMenu(dfd, ctxMenus, index + 1);
        });
      } else if (/update/.test(type)) {
        return chrome.contextMenus.update(id, ctxData, function() {
          return registerCtxMenu(dfd, ctxMenus, index + 1);
        });
      }
    } else {
      return dfd.resolve();
    }
  };

  createCtxMenus = function() {
    var ctxMenuFolderSet, dfdMain, keyConfigSet;
    if (keyConfigSet = andy.local.keyConfigSet) {
      ctxMenuFolderSet = andy.local.ctxMenuFolderSet;
      dfdMain = $.Deferred();
      chrome.contextMenus.removeAll(function() {
        var ctxMenus, targetCtxMenus;
        targetCtxMenus = [];
        keyConfigSet.forEach(function(keyConfig) {
          var ctxMenu;
          if ((ctxMenu = keyConfig.ctxMenu)) {
            ctxMenu.id = keyConfig["new"];
            ctxMenu.order = ctxMenu.order || 999;
            if (keyConfig.mode === "through") {
              ctxMenu.type = "create pause";
            } else {
              ctxMenu.type = "create";
            }
            return targetCtxMenus.push(ctxMenu);
          }
        });
        targetCtxMenus.sort(function(a, b) {
          return a.order - b.order;
        });
        ctxMenus = [];
        targetCtxMenus.forEach(function(ctxMenu) {
          var existsFolder, folder, i, _i, _j, _ref, _ref1;
          if (ctxMenu.parentId !== "route") {
            existsFolder = false;
            for (i = _i = 0, _ref = ctxMenus.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              if (ctxMenus[i].id === ctxMenu.parentId) {
                existsFolder = true;
                break;
              }
            }
            if (!existsFolder) {
              for (i = _j = 0, _ref1 = ctxMenuFolderSet.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                if (ctxMenuFolderSet[i].id === ctxMenu.parentId) {
                  folder = ctxMenuFolderSet[i];
                  ctxMenus.push({
                    id: folder.id,
                    order: ctxMenu.order,
                    parentId: "route",
                    type: "create",
                    caption: folder.title,
                    contexts: folder.contexts
                  });
                  break;
                }
              }
            }
          }
          return ctxMenus.push(ctxMenu);
        });
        return registerCtxMenu(dfdMain, ctxMenus, 0);
      });
      return dfdMain.promise();
    }
  };

  $(function() {
    var getHelp;
    andy.setLocal().done(function() {
      var keyConfigSet;
      if (keyConfigSet = andy.local.keyConfigSet) {
        setConfigPlugin(keyConfigSet);
        return createCtxMenus();
      }
    });
    getHelp = function(lang) {
      var dfd;
      $.get(scHelpPageUrl + lang).done(function(responseText) {
        analyzeScHelpPage(responseText, lang);
        return dfd.resolve();
      });
      return (dfd = $.Deferred()).promise();
    };
    return getHelp("ja").done(function() {
      return getHelp("en").done(function() {
        delete scHelp["-"];
        delete scHelp["+"];
        scHelp["CTRL+;"] = {
          ja: ["W^ページ全体を拡大表示します。"]
        };
        scHelp["CTRL+="] = {
          en: ["W^Enlarges everything on the page."]
        };
        return scHelp["CTRL+-"] = {
          en: ["W^Makes everything on the page smaller."],
          ja: ["W^ページ全体を縮小表示します。"]
        };
      });
    });
  });

}).call(this);
